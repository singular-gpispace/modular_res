

LIB "elim.lib";

proc iterative_Odd_rncAntiCanonicalMap(ideal I) {
    int n = nvars(basering);
    if((n mod 2) == 1){ERROR("Pn has even dimension");}
    def Roriginal = basering;
    list rlo = ring_list(Roriginal);
    rlo[3] = list(list("dp", 1:n), list("C", 0));
    
    int k;
    for (k = 1; k <= n; k++) {
        rlo[2][k] = "z(" + string(k) + ")";
    }
    def RoriginalCopy = ring(rlo);
    
    for (k = 1; k <= n; k++) {
        rlo[2][k] = "y(" + string(k) + ")";
    }
    def Rold = ring(rlo);
    
    setring RoriginalCopy;
    ideal PR;
    ideal PHI = maxideal(1);
    
    setring Rold;
    ideal J = fetch(Roriginal, I);
   
    list rl2;
    def Rnew;
    def Rbig;
    def Relim;
    intvec HJJ;
    list L;
    int counter=1;
    // Iterative process
    while (n > 2) {
       // print("working Ring="); print(Rold);
        //print("input J="); print(J);

        // Calculate PR using the modular RNC anti-canonical map
        ideal PR = modular_rncAntiCanonicalMap(J);
        
        //print("anticanonical PR in iterations="); print(PR);
        
        list rl = ring_list(Rold);
        Rbig = Rold + RoriginalCopy;
        
        setring Rbig;
        ideal PHI = imap(RoriginalCopy, PHI);
        ideal dummy = imap(Rold, PR);
        
        for (k = 1; k <= n; k++) {
            dummy = subst(dummy, var(k), PHI[k]);
        }
        
        setring RoriginalCopy;
        PHI = imap(Rbig, dummy);

        /* Workaround elimination */
        setring Rold;
        for (k = 1; k <= n; k++) {
            rl[2][k] = "x(" + string(k) + ")";
        }
        for (k = 1; k <= n - 2; k++) {
            rl[2][k + n] = "y(" + string(k) + ")";
        }
        
        rl[3] = list(list("dp", 1:(2 * n - 2)), list("C", 0));
        Relim = ring(rl);
        
        setring Relim;
        ideal J = fetch(Rold, J);
        ideal PR = fetch(Rold, PR);  // Update PR
        ideal JJ = J;

        poly pvar = 1;
        for (k = 1; k <= n; k++) {
            pvar = pvar * var(k);
        }
        
        for (k = 1; k <= n - 2; k++) {
            JJ = JJ, var(k + n) - PR[k];
        }
        
        ideal SJJ = std(JJ);
        HJJ = hilb(SJJ, 1);
        
        J = eliminate(JJ, pvar, HJJ);
        
        list rl = ring_list(Relim);
        rl2 = rl[2];
        rl[2] = list(rl2[n + 1..2 * n - 2]);
        rl[3] = list(list("dp", 1:(n - 2)), list("C", 0));
        
        Rnew = ring(rl);
        
        setring Rnew;
        ideal J = imap(Relim, J);
        
      
        Rold = Rnew;
        setring Rold;
        
        n = n - 2;
        setring Roriginal;
        ideal PR=fetch(Relim, PR); 
        L[counter]=PR;
        setring Rold;
        counter++;

    }


    setring Roriginal;
    return(L);  
}



proc iterative_Even_rncAntiCanonicalMap(ideal I) {
    int n = nvars(basering);
    if((n mod 2) == 0){ERROR("Pn has odd dimension");}    
    def Roriginal = basering;
    list rlo = ring_list(Roriginal);
    rlo[3] = list(list("dp", 1:n), list("C", 0));
    
    int k;
    for (k = 1; k <= n; k++) {
        rlo[2][k] = "z(" + string(k) + ")";
    }
    def RoriginalCopy = ring(rlo);
    
    for (k = 1; k <= n; k++) {
        rlo[2][k] = "y(" + string(k) + ")";
    }
    def Rold = ring(rlo);
    
    setring RoriginalCopy;
    ideal PR;
    ideal PHI = maxideal(1);
    
    setring Rold;
    ideal J = fetch(Roriginal, I);
   
    list rl2;
    def Rnew;
    def Rbig;
    def Relim;
    intvec HJJ;
    list L;
    int counter=1;
    // Iterative process
    while (n > 2) {
       // print("working Ring="); print(Rold);
        //print("input J="); print(J);

        // Calculate PR using the modular RNC anti-canonical map
        ideal PR = modular_rncAntiCanonicalMap(J);
        
        //print("anticanonical PR in iterations="); print(PR);
        
        list rl = ring_list(Rold);
        Rbig = Rold + RoriginalCopy;
        
        setring Rbig;
        ideal PHI = imap(RoriginalCopy, PHI);
        ideal dummy = imap(Rold, PR);
        
        for (k = 1; k <= n; k++) {
            dummy = subst(dummy, var(k), PHI[k]);
        }
        
        setring RoriginalCopy;
        PHI = imap(Rbig, dummy);

        /* Workaround elimination */
        setring Rold;
        for (k = 1; k <= n; k++) {
            rl[2][k] = "x(" + string(k) + ")";
        }
        for (k = 1; k <= n - 2; k++) {
            rl[2][k + n] = "y(" + string(k) + ")";
        }
        
        rl[3] = list(list("dp", 1:(2 * n - 2)), list("C", 0));
        Relim = ring(rl);
        
        setring Relim;
        ideal J = fetch(Rold, J);
        ideal PR = fetch(Rold, PR);  // Update PR
        ideal JJ = J;

        poly pvar = 1;
        for (k = 1; k <= n; k++) {
            pvar = pvar * var(k);
        }
        
        for (k = 1; k <= n - 2; k++) {
            JJ = JJ, var(k + n) - PR[k];
        }
        
        ideal SJJ = std(JJ);
        HJJ = hilb(SJJ, 1);
        
        J = eliminate(JJ, pvar, HJJ);
        
        list rl = ring_list(Relim);
        rl2 = rl[2];
        rl[2] = list(rl2[n + 1..2 * n - 2]);
        rl[3] = list(list("dp", 1:(n - 2)), list("C", 0));
        
        Rnew = ring(rl);
        
        setring Rnew;
        ideal J = imap(Relim, J);
        
      
        Rold = Rnew;
        setring Rold;
        
        n = n - 2;
        setring Roriginal;
        ideal PR=fetch(Relim, PR); 
        L[counter]=PR;
        setring Rold;
        counter++;

    }


    setring Roriginal;
    return(L);  
}











proc modular_rncAntiCanonicalMap(ideal J)


{
ideal I=std(J);
  def Roriginal = basering;
  list rl = ring_list(Roriginal);
  rl[3] = list(list("dp",1:nvars(Roriginal)),list("C",0));
  def RoriginalDP = ring(rl);
  setring RoriginalDP;
  ideal I = imap(Roriginal,I);
  int c0 = nvars(RoriginalDP)-2;
  //module AKD1 = Ext_R(c0,I);
  //print("Ext_module AKD1=");
  //print(AKD1);
  int cc = nvars(RoriginalDP);
  //print("c0=");print(c0);
   //def resI = minres(I, 0);
   def ResI=mres(I,0);
 int n=size(ResI);
 //print("size of ResI="); print(n);
 

  module lastSyzygyMatrix =ResI[n];
  matrix A=lastSyzygyMatrix;
  typeof(A);
  module AKD=A;//coker(A)=ker(A^T);
  //print("cokernel");
  //print(AKD);
  //def AKD =A;
  //Module AKD=AKD1;
 //print("anticanonical module AKD=");
  //print(AKD);
  qring qI = std(I);
  matrix AKD = imap(RoriginalDP,AKD);
  AKD = syz(AKD);
  ideal PR = submat(AKD,1..nrows(AKD),1);
  setring Roriginal;
  return(imap(qI,PR));
}



proc modular_rncItProjOdd(ideal I)

{
  int n = nvars(basering);
  if((n mod 2) == 1){ERROR("Pn has even dimension");}
  def Roriginal = basering;
  list rlo = ring_list(Roriginal);
  rlo[3]= list(list("dp",1:n),list("C",0));
  int k;
  for(k = 1; k <= n; k++)
    {
      rlo[2][k] = "z("+string(k)+")";
    }
  def RoriginalCopy = ring(rlo);
  for(k = 1; k <= n; k++)
    {
      rlo[2][k] = "y("+string(k)+")";
    }
  def Rold = ring(rlo);
  setring RoriginalCopy;
  ideal PHI  = maxideal(1);
  setring Rold;
  ideal J = fetch(Roriginal,I);
 
  list rl2;
  def Rnew;
  def Rbig;
  def Relim;
  //bigintvec HJJ;
  intvec HJJ;
  while(n>2)
     {
       print("working Ring=");print(Rold);
         print("input J=");print(J);
        ideal PR = modular_rncAntiCanonicalMap(J);
        print("anticanonical PR="); print(PR);
        list rl = ring_list(Rold);
        Rbig = Rold + RoriginalCopy;
        setring Rbig;
        ideal PHI = imap(RoriginalCopy,PHI);
        ideal dummy = imap(Rold,PR);
        for(k = 1; k <= n; k++)
          {
             dummy = subst(dummy,var(k),PHI[k]);
          }
        setring RoriginalCopy;
        PHI = imap(Rbig,dummy);
        /* begin workaround elimination*/
        setring Rold;
        for(k = 1; k <= n; k++)
          {
            rl[2][k] = "x("+string(k)+")";
          }
        for(k = 1; k <= n-2; k++)
          {
            rl[2][k+n] = "y("+string(k)+")";
          }
        rl[3]= list(list("dp",1:(2*n-2)),list("C",0));
        Relim = ring(rl);
        setring Relim;
        ideal J = fetch(Rold,J);
        ideal PR = fetch(Rold,PR);
        ideal JJ = J;
       
        poly pvar=1;
        for(k = 1; k <= n; k++)
          {
            pvar = pvar*var(k);
          }
        for(k=1;k<=n-2;k++)
          { 
            JJ=JJ,var(k+n)-PR[k];
          }
        ideal SJJ = std(JJ);
        HJJ = hilb(SJJ,1);
        J = eliminate(JJ,pvar,HJJ);
        list rl = ring_list(Relim);
        rl2 = rl[2];
        rl[2] = list(rl2[n+1..2*n-2]);
        rl[3]= list(list("dp",1:(n-2)),list("C",0));
        Rnew = ring(rl);
        setring Rnew;
        ideal J = imap(Relim,J);
        /* end workaround elimination*/
        Rold = Rnew;
        setring Rold;
        n = n-2;
     }
  setring Roriginal;
  return(fetch(RoriginalCopy,PHI));
}






proc modular_rncItProjEven(ideal I)

{
  int n = nvars(basering);
  if((n mod 2) == 0){ERROR("Pn has odd dimension");}
  def Roriginal = basering;
  list rlo = ring_list(Roriginal);
  rlo[3]= list(list("dp",1:n),list("C",0));
  int k;
  for(k = 1; k <= n; k++)
    {
      rlo[2][k] = "z("+string(k)+")";
    }
  def RoriginalCopy = ring(rlo);
  for(k = 1; k <= n; k++)
    {
      rlo[2][k] = "y("+string(k)+")";
    }
  def Rold = ring(rlo);
  setring RoriginalCopy;
  ideal PHI  = maxideal(1);
  setring Rold;
  ideal J = fetch(Roriginal,I);
  list rl2;
  def Rnew;
  def Rbig;
  def Relim;
  bigintvec HJJ;
  while(n>3)
     {
        ideal PR = modular_rncAntiCanonicalMap(J);
        list rl = ring_list(Rold);
        Rbig = Rold + RoriginalCopy;
        setring Rbig;
        ideal PHI = imap(RoriginalCopy,PHI);
        ideal dummy = imap(Rold,PR);
        for(k = 1; k <= n; k++)
          {
             dummy = subst(dummy,var(k),PHI[k]);
          }
        setring RoriginalCopy;
        PHI = imap(Rbig,dummy);
        /* begin workaround elimination*/
        setring Rold;
        for(k = 1; k <= n; k++)
          {
            rl[2][k] = "x("+string(k)+")";
          }
        for(k = 1; k <= n-2; k++)
          {
            rl[2][k+n] = "y("+string(k)+")";
          }
        rl[3]= list(list("dp",1:(2*n-2)),list("C",0));
        Relim = ring(rl);
        setring Relim;
        ideal J = fetch(Rold,J);
        ideal PR = fetch(Rold,PR);
        ideal JJ = J;
        poly pvar=1;
        for(k = 1; k <= n; k++)
          {
            pvar = pvar*var(k);
          }
        for(k=1;k<=n-2;k++)
          {
            JJ=JJ,var(k+n)-PR[k];
          }
        ideal SJJ = std(JJ);
        HJJ = hilb(SJJ,1);
        J = eliminate(JJ,pvar,HJJ);
        list rl = ring_list(Relim);
        rl2 = rl[2];
        rl[2] = list(rl2[n+1..2*n-2]);
        rl[3]= list(list("dp",1:(n-2)),list("C",0));
        Rnew = ring(rl);
        setring Rnew;
        ideal J = imap(Relim,J);
        /* end workaround elimination*/
        Rold = Rnew;
        setring Rold;
        n = n-2;
     }
  poly CONIC = J[1];
  export(CONIC);
  setring Roriginal;
  ideal PHI = fetch(RoriginalCopy,PHI);
  export(PHI);
  return(Rold);
}





proc invertBirMap(ideal phi, ideal I)

{
   def Roriginal = basering;
   int n = nvars(Roriginal);
   int m = size(phi);
   /*phi: P^(n-1) --> P^(m-1)*/
   list rl = ring_list(Roriginal);
   int k;
   for(k = 1; k <= n; k++)
     {
        rl[2][k] = "x("+string(k)+")";
     }
   for(k = 1; k <= m; k++)
     {
        rl[2][k+n] = "y("+string(k)+")";
     }
   rl[3]= list(list("dp",1:(n+m)),list("C",0));
   /*Use Hilbert driven Buchberger*/
   def Rbig0 = ring(rl);
   setring Rbig0;
   ideal I = fetch(Roriginal,I);
   ideal phi = fetch(Roriginal,phi);
   ideal mi = maxideal(1);
   print("mi in inverBirMap=");print(mi);
   ideal xv = mi[1..n];
   print("ideal xv=");print(xv);
   ideal yv  = mi[n+1..n+m];
   print("m=");print(m);print("n=");print(n);
   print("ideal yv=");print(yv);
   matrix HM[2][m] = concat(transpose(yv),transpose(phi));
   ideal graph = sat(I+minor(HM,2),phi)[1];
   graph = sat(graph,xv)[1];
   intvec Hgraph = hilb(graph,1);
   setring Roriginal;
   rl[3]= list(list("dp",1:n),list("dp",1:m),list("C",0));
   def Rbig = ring(rl);
   setring Rbig;
   ideal graph = imap(Rbig0,graph);
   graph = std(graph,Hgraph);
   ideal xv = imap(Rbig0,xv);
   /*The ideal J defines the image of phi*/
   ideal J = graph;
   for(k = 1; k <= n; k++)
     {
        J = subst(J,xv[k],0);
     }
   J = compress(J);
   /*now we start inverting phi to psi*/
   matrix relpsi = diff(xv,graph);
   for(k = 1; k <= n; k++)
     {
        relpsi = subst(relpsi,xv[k],0);
     }
    relpsi = compress(relpsi);
    list rl = ring_list(Rbig);
    list rl2 = rl[2];
    rl[2] = list(rl2[n+1..n+m]);
    rl[3]= list(list("dp",1:m),list("C",0));
    def Rtarget = ring(rl);
    setring Rtarget;
    ideal J = imap(Rbig,J);
    qring RtargetmodJ = std(J);
    matrix relpsi = imap(Rbig,relpsi);
    relpsi = syz(transpose(relpsi));
    ideal psi = submat(relpsi,1..nrows(relpsi),1);
    setring Rtarget;
    ideal psi = imap(RtargetmodJ,psi);
    export(J,psi);
    int p = printlevel - voice + 3;
    dbprint(p,"// 'invertBirMap' created a ring together with two ideals J and psi.");
    dbprint(p,"// Supposing you typed, say,  def RPn = invertBirMap(phi,I);");
    dbprint(p,"// you may access the ideals by typing");
    dbprint(p,"//      setring RPn; J; psi;");
    return(Rtarget);
 }



proc modular_invertBirMap(ideal J0, ideal I) {
    def Roriginal = basering;
    int n = nvars(Roriginal);
    int m = size(J0);
    
   
    
    // Initialize the graph
    list rl = ring_list(Roriginal);
       int k;
   for(k = 1; k <= n; k++)
     {
        rl[2][k] = "x("+string(k)+")";
     }
   for(k = 1; k <= m; k++)
     {
        rl[2][k+n] = "y("+string(k)+")";
     }

    rl[3] = list(list("dp", 1:(n + m)), list("C", 0));
    def Rbig0 = ring(rl);
   setring Rbig0;
    ideal I = fetch(Roriginal, I);
    ideal J0 = fetch(Roriginal, J0);
    
    ideal mi = maxideal(1);
    print("mi=");print(mi);
   ideal xv = mi[1..n];
   print("ideal xv=");print(xv);
   ideal yv  = mi[n+1..n+m];
   print("m=");print(m);print("n=");print(n);
   print("ideal yv=");print(yv);

    matrix HM[2][m] = concat(transpose(yv),transpose(J0));
   ideal graph = sat(I+minor(HM,2),J0)[1];
   graph = sat(graph,xv)[1];
    
   intvec Hgraph = hilb(graph,1);
   setring Roriginal;
   rl[3]= list(list("dp",1:n),list("dp",1:m),list("C",0));
   def Rbig = ring(rl);
   setring Rbig;
   ideal graph = imap(Rbig0,graph);
   graph = std(graph,Hgraph);
   ideal xv = imap(Rbig0,xv);
   /*The ideal J defines the image of phi*/
   ideal J = graph;
   for(k = 1; k <= n; k++)
     {
        J = subst(J,xv[k],0);
     }
   J = compress(J);
   /*now we start inverting phi to psi*/
   matrix relpsi = diff(xv,graph);
   for(k = 1; k <= n; k++)
     {
        relpsi = subst(relpsi,xv[k],0);
     }
    relpsi = compress(relpsi);
    list rl = ring_list(Rbig);
    list rl2 = rl[2];
    rl[2] = list(rl2[n+1..n+m]);
    rl[3]= list(list("dp",1:m),list("C",0));
    def Rtarget = ring(rl);
    setring Rtarget;
    ideal J = imap(Rbig,J);
    qring RtargetmodJ = std(J);
    matrix relpsi = imap(Rbig,relpsi);
    relpsi = syz(transpose(relpsi));
    ideal psi = submat(relpsi,1..nrows(relpsi),1);
    setring Rtarget;
    ideal psi = imap(RtargetmodJ,psi);
    export(J,psi);
    int p = printlevel - voice + 3;
    dbprint(p,"// 'invertBirMap' created a ring together with two ideals J and psi.");
    dbprint(p,"// Supposing you typed, say,  def RPn = invertBirMap(phi,I);");
    dbprint(p,"// you may access the ideals by typing");
    dbprint(p,"//      setring RPn; J; psi;");
    return(Rtarget);
  }









